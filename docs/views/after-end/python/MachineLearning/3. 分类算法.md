# 分类算法
## 转换器 - 特征工程的父类
想一下之前做的特征工程的步骤？
1. 实例化(实例化的是一个转换器类(Transformer))
2. 调用 fit_transform (对于文档建立分类的词频矩阵，不能同时调用)

我们把特征工程的接口称之为转换器，其中转换器调用有这么几种形式
- fit_transform
- fit(X) 返回self
- transform(X)
## 估计器(sklearn 机器学习算法的实现)
在sklean中，估计器(estimator)是一个重要的概念。是一类实现了算法的API
1. 用于分类的估计器
  - sklearn.neighbors k-近邻算法
  - sklearn.naive_bayes 贝叶斯
  - sklearn.linear_model.LogisticRegression 逻辑回归
  - sklearn.tree 决策树与随机森林
2. 用于回归的估计器
  - sklearn.linear_model.LinearRegression 线性回归
  - sklearn.linear_model.Ridge 岭回归

3. 用于无监督学习的估计器
  - sklearn.cluster.KMeans 聚类

### 预估器工作流程
1. 训练集(x_train, y_train) - x_train: 训练集的特征值，y_train: 训练集的目标值
2. 实例化一个 estimator
3. estimator.fit(x_train, y_train) 计算
  ——调用完毕，模型生成
4. 模型评估：
  1) 直接比对真实值和预测值
      y_predict = estimator.predict(x_test)
      y_test == y_predict
  2) 计算准确率
      accuracy = estimator.score(x_test, y_test) - x_test: 测试集的特征值，y_test: 测试集的目标值
  
## K-近邻算法(根据你的邻居来推断出你的类别)
### K-近邻算法(KNN)算法原理
K Nearest Neighbor 算法又叫KNN算法，这个算法是机器学习里面一个比较经典的算法，总体来说KNN算法是相对比较容易理解的算法
#### 定义
如果一个枕头套在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别

#### 距离公式
两个样本的距离可以通过如下公式计算，又叫欧式距离。比如说，a(a1, a2, a3), b(b1, b2, b3)
sqrt((a1 - b1) ^ 2 + (a2 - b2) ^ 2 + (a3 - b3) ^ 2)

曼哈顿距离(绝对值距离)

明可夫斯基距离 

#### 电影类型分析
假设有一批电影，每部电影都有三个特征，分别是动作，冒险，爱情，根据这些特征，我们可以把电影分成不同的类型，比如动作片，冒险片，爱情片

|电影名称|打斗镜头|接吻镜头|电影类型|
|-------|--------|--------|--------|
|california Man|2|104|爱情片|
|He's notReally into dues'|2|100|爱情片|
|Beautiful Woman|1|81|爱情片|
|Kevin Longbiads|101|10|动作片|
|Robo Siayer 30000|99|5|动作片|
|Amped ll|98|2|动作片|
| ? |18|90|未知|
其中 ? 号电影不知道类别，如何去预测？可以利用 K 近邻算法的思想
|电影名称|与未知电影的距离|
|-------|---------------|
|california Man|20|
|He's notReally into dues'|18.7|
|Beautiful Woman|19.2|
|Kevin Longbiads|115.3|
|Robo Siayer 30000|117.4|
|Amped ll|118.9|

##### 问题
- 如果取的最近的电影数量不一样？会是什么结果？
  - k = 1, 爱情片。
  - k = 2 爱情片
  - k = 6 无法确定
  - k = 7 动作片
  - k 值取得过大，样本不均衡的影响
  - k 值取得过小，容易受异常值影响
  
  需要进行无量纲化的处理
### K-近邻算法(KNN)API
```python
sklearn.neighbors.KNeighborsClassifier(n_neighbors = 5, algorithm = 'auto')
# n_neighbors: int, 可选(默认为5), k_neighbors 查询默认使用的邻居数
# algorithm: {‘auto’, ‘ball_tree’, ‘kd_tree’, ‘brute’}, 可选用于计算最近邻居的算法

# ‘ball_tree’：将会使用BalTree, 在球树中执行最近邻搜索
# ‘kd_tree’：将使用KDTree, 在kd树中执行最近邻搜索
# ‘auto’：将尝试要付传递给fit 方法的值来决定最合适的算法。如果数据集的维度小于20，则使用kd树。否则使用球树。
# ‘brute’：将使用暴力搜索
```
### 案例1：鸢尾花种类预测
#### 数据集介绍
iris 数据集是常用的分类实验数据集，由Fisher, 1936 收集整理。Iris也称鸢尾花卉数据集，是一类多重变量分析的数据集。关于数据集的具体介绍：
- 实例数据：150(三个类各有50个)
- 属性数量：4(数值型，数值型，帮助预测的属性和类)
- Attribute Information:
  - sepal length 萼片长度 (cm)
  - sepal width 萼片宽度 (cm)
  - petal length 花瓣长度 (cm)
  - petal width 花瓣宽度 (cm)
  - class:
    iris-Setosa 山鸢尾
    iris-Versicolour 变色鸢尾
    iris-Virginica 维吉尼亚鸢尾

#### 代码实现
```python
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier

def knn_iris():
  """
    用 KNN 算法对鸢尾花数据集进行分类
  """
  # 1 获取数据
  iris = load_iris()
  # 2 划分数据集
  #                                                   特征值，    目标值
  x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state = 6)
  # 3 特征工程：标准化
  transfer = StandardScaler()
  x_train = transfer.fit_transform(x_train)

  x_test = transfer.transform(x_test)
  # 4 KNN算法预估
  estimator = KNeighborsClassifier(n_neighbors=3)
  estimator.fit(x_train, y_train)
  # 5 模型评估
  # 方法1：直接比双真实值和预测值
  y_predict = estimator.predict(x_test)
  print("y_predict:\n", y_predict)
  print("直接比对真实值和预测值：\n", y_test == y_predict)

  # 方法2：计算准确率
  score = estimator.score(x_test, y_test)
  print("准确率为：\n", score)

  return None

if __name__ == "__main__":
  knn_iris()
```
### 总结
- 优点：简单，易于理解，易于实现，无需估计参数
- 缺点：
  - 懒惰算法，对测试样本分类时的计算量大，内存开销大
  - 必须指定K值，K值选择不当则分类精度不能保证
- 使用场景：小数据场景，几千~几成样本，具体场景具体业务去测试