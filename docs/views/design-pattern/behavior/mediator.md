# 中介者模式
## 介绍
中介者模式是一种行为设计模式，它定义了一个对象来封装系统中对象之间的交互方式。这种模式可以减少对象间的相互依赖，从而使得你能够独立地复用这些对象。在中介者模式中，各个同事类（Colleague）之间不直接通信，而是通过一个中介者（Mediator）来协调它们的行为。
1. 抽象中介者（Mediator）：声明一个接口用于聚集同事对象。
2. 具体中介者（Concrete Mediator）：实现抽象中介者定义的行为。它需要处理所有同事发出的通知，并且负责向相应的同事发送消息。
3. 抽象同事类（Colleague）：定义一个接口用于与中介者对象通信。通常包括至少一个或多个用于接收消息的方法。
4. 具体同事类（Concrete Colleagues）：实现抽象同事类定义的行为。每一个具体同事都只知道它的中介者，并通过中介者与其他同事通信。
## 使用场景
当一组对象以一种很复杂的方式协作时，可以使用中介者模式简化这一组对象之间的交互。
如果发现一个系统的通信网络过于复杂，可以引入中介者来简化这个网络。
如果想要定制一个分布在多个实例上的行为，可以使用中介者模式来避免在同事类中指定太多的行为。

中介者模式适用于那些需要解耦原本紧密相连的对象之间的交互，并希望简化这些对象间通信的情况。以下是一些适合应用中介者模式的业务场景：

1. 多对象交互复杂：当一个系统中有多个对象，这些对象之间存在复杂的依赖关系和频繁的交互时，可以考虑使用中介者模式来降低对象间的耦合度。

2. 命令调度中心：在一些系统中，存在一个中心点来处理各种请求或者事件的调度工作，比如在UI框架中，按钮点击、窗口关闭等事件的处理，都可以通过中介者来进行集中管理。

3. 分布式系统协调：在分布式系统中，多个服务之间需要协同工作时，可以通过中介者模式来作为服务之间的协调者，减轻服务间的直接调用带来的复杂性。

4. MVC架构中的Controller：在MVC（Model-View-Controller）架构中，Controller可以看作是一个中介者，负责处理View和Model之间的通信。

5. 聊天室或论坛系统：在聊天室或论坛系统中，用户（同事）之间的信息传递可以通过一个聊天室或服务器（中介者）来完成。

6. 智能家居控制系统：在一个智能家居系统中，不同的设备（如灯光、空调、窗帘等）可能需要根据特定的条件进行联动控制，此时可以通过一个智能中心（中介者）来进行设备间的协调。

7. 交易市场或拍卖平台：在交易市场或拍卖平台上，买家和卖家之间的交易活动可以通过一个平台（中介者）来进行撮合和监管。

8. 多线程或异步任务管理：在并发编程或多线程环境中，多个线程或任务之间需要同步或协调时，可以通过一个任务调度器（中介者）来统一管理和调度。

9. 游戏开发中的游戏引擎：在游戏中，不同游戏对象（如角色、怪物、物品等）之间可能存在复杂的互动，可以通过游戏引擎中的某些组件作为中介者来管理这些互动。

10. 企业级应用集成：在企业级应用集成（EAI）领域，不同系统之间需要互相交换数据或消息时，可以采用中介者模式来作为一个集成总线或消息队列。

总的来说，中介者模式适用于需要减少对象之间直接依赖，以及需要对交互进行集中管理和控制的场景。通过使用中介者模式，可以提高系统的可扩展性和可维护性。

## 优点
封装了同事之间的通信逻辑，使得同事类更加高内聚，低耦合。
可以减少子系统中的对象数量，因为同事类不需要维护指向其他同事类的引用。

## 缺点
如果设计不当，中介者类可能会变得庞大且难以维护。
中介者类承担了过多责任，使得职责划分不明确。

## 案例

```python
'''
假设我们需要开发一个简单的聊天室应用程序，用户可以在聊天室内发送消息，每个用户只能看到聊天室内的消息，而不能直接与其他用户通信。这可以通过使用中介者模式来实现，其中聊天室作为中介者，管理用户（同事）之间的通信。
'''

# 设计
# 首先，定义一个抽象的中介者接口 ChatRoom，然后定义具体的中介者
# ConcreteChatRoom。接着，定义一个抽象的同事类 User 和具体的同事类ConcreteUser。

# 1. 定义抽象中介者
# 抽象中介者定义了展示消息的基本方法
class ChatRoom:
    def display_message(self, user, message):
        # 子类需要实现的具体方法
        pass

# 2. 定义具体中介者
class ConcreteChatRoom(ChatRoom):
    def __init__(self):
        # 初始化一个空列表来存储用户
        self.users = []

    def add_user(self, user):
        # 添加用户到聊天室
        self.users.append(user)

    def display_message(self, user, message):
        # 遍历所有用户，除了发送消息的用户外，向其他用户发送消息
        for u in self.users:
            if u != user:
                u.receive(message)

# 3. 定义抽象同事类
# 抽象同事类定义了发送和接收消息的方法
class User:
    def send(self, message):
        # 发送消息的抽象方法
        pass

    def receive(self, message):
        # 接收消息的抽象方法
        pass

# 4. 定义具体同事类
class ConcreteUser(User):
    def __init__(self, name, chat_room):
        # 初始化用户的名字和关联的聊天室
        self.name = name
        self.chat_room = chat_room

    def send(self, message):
        # 通过聊天室发送消息
        self.chat_room.display_message(self, message)

    def receive(self, message):
        # 打印接收到的消息
        print(f'{self.name}: {message}')

# 使用
# 现在我们可以创建一些用户并让他们加入聊天室，然后让他们发送消息。
def main():
    # 创建一个具体的聊天室实例
    chat_room = ConcreteChatRoom()

    # 创建两个用户实例，并关联到聊天室
    alice = ConcreteUser('Alice', chat_room)
    bob = ConcreteUser('Bob', chat_room)
    
    # 添加用户到聊天室
    chat_room.add_user(alice)
    chat_room.add_user(bob)

    # 用户发送消息
    alice.send('Hello Bob!')
    bob.send('Hi Alice!')

if __name__ == '__main__':
    main()

# 输出：
# Alice: Hello Bob!
# Bob: Hi Alice!


'''
详细解释
1. 抽象中介者 (ChatRoom):
- 定义了 display_message 方法的接口，具体实现由子类完成。
2. 具体中介者 (ConcreteChatRoom):
- 维护一个用户列表。
- 提供 add_user 方法来增加用户到聊天室。
- 实现了 display_message 方法，用于向除发送消息的用户外的所有用户转发消息。
3. 抽象同事类 (User):
- 定义了 send 和 receive 方法的接口，具体实现由子类完成。
4. 具体同事类 (ConcreteUser):
- 每个用户都有自己的名字和关联的聊天室。
- 实现了 send 方法，通过调用聊天室的 display_message 方法来发送消息。
- 实现了 receive 方法，用来打印接收到的消息。
5. 使用 (main 函数):
- 创建一个具体的聊天室实例。
- 创建两个用户实例，并将它们关联到聊天室。
- 将用户添加到聊天室。
- 用户通过 send 方法发送消息，消息通过聊天室被其他用户接收。

通过这个案例，你可以看到中介者模式是如何通过一个中心化的对象（中介者）来管理多个对象（同事）之间的交互，从而减少了对象间的直接耦合。
'''
```