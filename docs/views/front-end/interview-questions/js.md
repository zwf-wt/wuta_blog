# JS相关面试题

## 1. 如果判断一个数据是NaN
NaN 表示非数字 但是用 typeof 检测是 number类型，所以利用 NaN的定义： 用typeof判断是否为 number类型并且判断是否满足isnan
利用 NaN 是唯一个不等于任何自身的特点 n! ==n利用 
```js

let n = Number('a') // NaN
console.log('是否是NaN', n != n) // 是否是NaN, true
console.log(Object.is(n, NaN)) // true
```
## 2. Js 中 null 5 undefined 区别
- 相同点: 用if判断时，两者都会被转换成 false
- 不同点:
  
  1. number转换的值不同 number (null) 为0,  number (undefined)为 NaN
  2. Null 表示一个值被定义了，但是这个值是空值
  3. Undefined 变量声明但未赋值

## 3. 闭包是什么?有什么特性? 对页面会有什么影响
> 闭包可以简单理解成: 定义在一个函数内部的函数。其中一个内部函数在包含它们的外部函数之外被调用时，就会形成闭包特点:
1. 函数嵌套函数
2. 函数内部可以引用外部的参数和变量
3. 参数和变量不会被垃圾回收机制回收。
> 使用:
1. 读取函数内部的变量;
2. 这些变量的值始终保持在内存中，不会在外层函数调用后被自动清除

> 优点:
1. 变量长期驻扎在内存中
2. 避免全局变量的污染
3. 私有成员的存在
> 缺点:会造成内存泄露

## 4. Js 中常见的内存泄漏
1. 意外的全局变量
2. 被遗忘的计时器或回调函数
3. 脱离 DOM的引用
4. 闭包

## 5. ES6 新特性

1. const和 let
2.模板字符串
3. 箭头函数
4. 函数的参数默认值
5. 对象和数组解构
6. for..of 和 for.in
7. ES6 中的类
8. Promise

## 6.Let 与 var 与 const 的区别
- Var 声明的变量会挂载在 window 上，而let 和 const 声明的变量不会Var声明的变量存在变量提升
- let和 const不存在变量提升同一作用域下 var可以声明同名变量，let和 const 不可以
- Let和 const 声明会形成块级作用域
- Let暂存死区
- Const 一旦声明必须赋值，不能用 null 占位，声明后不能再修改，如果声明的是复合类型数据，可以修改属性

## 7.普通函数和构造函数的区别
1. 构造函数也是一个普通函数，创建方式和普通函数一样，但是构造函数习惯上首字母大写
2. 调用方式不一样，普通函数直接调用，构造函数要用关键字 new 来调用
3. 调用时，构造函数内部会创建一个新对象，就是实例，普通函数不会创建新对象
4. 构造函数内部的 this 指向实例，普通函数内部的 this 指向调用函数的对象 (如果没有对象调用，默认为 window)5.构造函数默认的返回值是创建的对象 (也就是实例)，普通函数的返回值由 return 语句决定
6. 构造函数的函数名与类名相同

## 8. 请简述原型/原型链/(原型) 继承
### 1. 什么是原型:
任何对象实例都有一个原型，也叫原型对象，这个原型对象由对象的内置属性 _proto_ 指向它的构造函数的 prototype指向的对象，即任何对象都是由一个构造函数创建的，但是不是每一个对象都有 prototype.只有方法才有 prototype.
### 2. 什么是原型链?
原型链基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。我们知道，每个构造函数都有一个原型对象，每个原型对象都有一个指向构造函数的指针，而实例又包涵一个指向原型对象的内部指针。
原型链的核心就是依赖对象的 _proto_ 的指向，当自身不存在的属性时，就一层层的扒出创建对象的构造函数，直至到 Object 时，就没有_proto_指向了.因为_proto_ 实质找的是 prototype，所以我们只要找这个链条 上的构造函数的 prototype。其中 Object.prototype 是没有 proto 属性的，它==null.
每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含指向原型对象内部的指针。我们让原型对象 (1)等于另一个原型对象的实例(2)此时原型对象 (2) 将包含一个指向原型对象 (1) 的指针再让原型对象(2)的实例等于原型对象 (3)，如此层层递进就构成了实例和原型的链条，这就是原型链的概念每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数想指针(constructon)，而实例对象都包含一个指向原型对象的内部指针(proto )。如果让原型对象等于另一个原型对象的实例，此时的原型对象将包含一个指向另一个原型的指针( proto )，另一个原型也包含着一个指向另一个构造函数的指针(constructor)。假如另个原型又是另一个类型的实例......这就构成了实例与原型的链条。也叫原型链原型继承是jis 的一种继承方式，原型链作为实现继承的主要方法,其基本思路是利用原型让一个引用类型继承另一个引用类型的属性和方法原型继承:利用原型中的成员可以被和其相关的对象共享这一特性，可以实现继承，这种实现继承的方式，就叫做原型继承.
## 9. Promise 的理解
1. 什么是 Promise?
我们都知道，Promise 是承诺的意思，承诺它过一段时间会给你一个结果。
Promise 是一种解决异步编程的方案，相比回调函数和事件更合理和更强大。
从语法上讲，promise 是一个对象，从它可以获取异步操作的消息
2. promise 有三种状态: pending 初始状态也叫等待状态，fulfiled成功状态,rejected失败状态;状态一旦改变,就不会再变。创造 promise实例后，它会立即执行
3. Promise 的两个特点
- Promise对象的状态不受外界影响
- Promise 的状态一旦改变，就不会再变，任何时候都可以得到这个结果，状态不可以逆
4. Promise 的二个缺点
- 无法取消 Promise,一旦新建它就会立即执行，无法中途取消
- 如果不设置回调函数，Promise 内部抛出的错误，不会反映到外部
- 当处于 pending (等待)状态时，无法得知目前进展到哪一个阶段是刚刚开始还是即将完成