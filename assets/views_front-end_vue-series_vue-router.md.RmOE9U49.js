import{_ as s,o as i,c as a,R as e}from"./chunks/framework.H90atOJc.js";const u=JSON.parse('{"title":"vue-router","description":"","frontmatter":{},"headers":[],"relativePath":"views/front-end/vue-series/vue-router.md","filePath":"views/front-end/vue-series/vue-router.md"}'),t={name:"views/front-end/vue-series/vue-router.md"},l=e(`<h1 id="vue-router" tabindex="-1">vue-router <a class="header-anchor" href="#vue-router" aria-label="Permalink to &quot;vue-router&quot;">​</a></h1><h2 id="路由参数" tabindex="-1">路由参数 <a class="header-anchor" href="#路由参数" aria-label="Permalink to &quot;路由参数&quot;">​</a></h2><h2 id="编程式导航" tabindex="-1">编程式导航 <a class="header-anchor" href="#编程式导航" aria-label="Permalink to &quot;编程式导航&quot;">​</a></h2><h2 id="路由懒加载" tabindex="-1">路由懒加载 <a class="header-anchor" href="#路由懒加载" aria-label="Permalink to &quot;路由懒加载&quot;">​</a></h2><h2 id="导航守卫" tabindex="-1">导航守卫 <a class="header-anchor" href="#导航守卫" aria-label="Permalink to &quot;导航守卫&quot;">​</a></h2><ol><li>全局前置守卫</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * 全局前置守卫</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * to: Route: 即将要进入的目标 路由信息对象</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * from: Route: 当前导航正要离开的路由</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * next: Function: 一定要调用该方法来 resolve 这个钩子</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">beforeEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;router beforeEach&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, to, from)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 必须调用 next()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><ol start="2"><li>全局解析守卫</li><li>全局后置钩子</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 全局后置守卫</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">afterEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;router afterEach&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, to, from)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><ol start="4"><li>路由独享守卫</li><li>组件内守卫</li></ol><h2 id="vue-router的两种模式" tabindex="-1">vue-router的两种模式 <a class="header-anchor" href="#vue-router的两种模式" aria-label="Permalink to &quot;vue-router的两种模式&quot;">​</a></h2><blockquote><p><code>Vue</code> 路由有两种模式：<code>hash</code> 模式和 <code>history</code> 模式。</p></blockquote><ol><li><code>hash</code> 模式：<code>URL</code> 中以 # 开头，如 <a href="http://www.example.com/#/home" target="_blank" rel="noreferrer">http://www.example.com/#/home</a> 原理是利用浏览器的 <code>hash（锚点）</code>来实现前端路由，当 <code>URL</code> 中的 <code>hash</code> 发生变化时，页面不会重新加载，而是通过监听 <code>hashchange</code> 事件来进行页面更新</li></ol><ul><li>优点：兼容性好，在不支持 <code>HTML5 History API</code> 的浏览器中也可以使用</li><li>缺点：URL 中有 <code>#</code> 可能影响 <code>SEO</code>，不够美观</li></ul><ol start="2"><li>history 模式：URL 中不包含 <code>#</code>，如 <a href="http://www.example.com/home" target="_blank" rel="noreferrer">http://www.example.com/home</a> 原理是利用 <code>HTML5 History API</code> 中的 <code>pushState</code> 和 <code>replaceState</code> 方法来改变 URL，并配合监听 <code>popstate</code> 事件来实现前端路由</li></ol><ul><li>优点：<code>URL</code> 美观，不会有 #，对 <code>SEO</code> 更友好</li><li>缺点：需要服务器端配置，防止用户直接访问 history 模式下的 URL 时出现 404 错误</li></ul><blockquote><p>总体来说，<code>hash</code> 模式兼容性好，使用简单，但 <code>URL</code> 不够美观；<code>history</code> 模式 <code>URL</code> 美观，对 <code>SEO</code> 更友好，但需要服务器端配置，且在一些老版本浏览器上可能存在兼容性问题。根据项目需求和实际情况选择合适的路由模式。</p></blockquote>`,17),n=[l];function h(o,r,p,k,d,c){return i(),a("div",null,n)}const g=s(t,[["render",h]]);export{u as __pageData,g as default};
