import{_ as s,o as i,c as a,R as n}from"./chunks/framework.H90atOJc.js";const u=JSON.parse('{"title":"函数","description":"","frontmatter":{},"headers":[],"relativePath":"views/interview-questions/js/function.md","filePath":"views/interview-questions/js/function.md"}'),t={name:"views/interview-questions/js/function.md"},e=n(`<h1 id="函数" tabindex="-1">函数 <a class="header-anchor" href="#函数" aria-label="Permalink to &quot;函数&quot;">​</a></h1><h2 id="_1-函数防抖" tabindex="-1">1. 函数防抖 <a class="header-anchor" href="#_1-函数防抖" aria-label="Permalink to &quot;1. 函数防抖&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> debounce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">duration</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 500</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timerId;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // return 返回的函数一定不要用箭头函数，因为保证 this 一致</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    clearTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timerId);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // setTimeout 一定要用箭头函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    timerId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      func.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }, duration);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="_2-函数节流" tabindex="-1">2. 函数节流 <a class="header-anchor" href="#_2-函数节流" aria-label="Permalink to &quot;2. 函数节流&quot;">​</a></h2><h2 id="_3-js-的函数节流和函数防抖的区别" tabindex="-1">3. Js 的函数节流和函数防抖的区别 <a class="header-anchor" href="#_3-js-的函数节流和函数防抖的区别" aria-label="Permalink to &quot;3. Js 的函数节流和函数防抖的区别&quot;">​</a></h2><ul><li>函数节流是指一定时间内<code>js</code>方法只执行一次, 函数防抖是指频繁触发的情况下，只有足够的空闲时间，才执行代码次</li><li>函数节流是 声明一个变量当标志位，记录当前代码是否在执行，如果正在执行，取消这次方法执行，直接<code>return</code>，如果空闲，正常触发方法执行</li><li>函数防抖是需要一个延时器来辅助实现，延迟执行需要执行的代码，如果方法多次触发，把上次记录的迟执行代码用<code>cleartimeout</code>清除掉重新开始，如果计时完毕，没有方法来访问触发，则执行代码</li></ul><h2 id="_4-普通函数和构造函数的区别" tabindex="-1">4.普通函数和构造函数的区别 <a class="header-anchor" href="#_4-普通函数和构造函数的区别" aria-label="Permalink to &quot;4.普通函数和构造函数的区别&quot;">​</a></h2><ol><li>构造函数也是一个普通函数，创建方式和普通函数一样，但是构造函数习惯上首字母大写</li><li>调用方式不一样，普通函数直接调用，构造函数要用关键字 new 来调用</li><li>调用时，构造函数内部会创建一个新对象，就是实例，普通函数不会创建新对象</li><li>构造函数内部的 this 指向实例，普通函数内部的 this 指向调用函数的对象 (如果没有对象调用，默认为 window)5.构造函数默认的返回值是创建的对象 (也就是实例)，普通函数的返回值由 return 语句决定</li><li>构造函数的函数名与类名相同</li></ol><h2 id="_5-this-指向" tabindex="-1">5. this 指向 <a class="header-anchor" href="#_5-this-指向" aria-label="Permalink to &quot;5. this 指向&quot;">​</a></h2><p>在<code>JavaScript</code>中，<code>this</code>通常指向的是我们正在执行的函数本身，或者是指向该函数所属的对象</p><ul><li>全局的<code>this</code>&gt;指向的是<code>Window</code></li><li>对象中的<code>this</code>指向其本身</li><li>事件中<code>this</code>&gt;指向事件对象</li></ul>`,11),l=[e];function h(p,k,r,d,o,c){return i(),a("div",null,l)}const g=s(t,[["render",h]]);export{u as __pageData,g as default};
