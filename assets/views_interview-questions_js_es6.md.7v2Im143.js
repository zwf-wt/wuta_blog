import{_ as e,o as a,c as s,R as i}from"./chunks/framework.MMMQMGZx.js";const b=JSON.parse('{"title":"ES6+","description":"","frontmatter":{},"headers":[],"relativePath":"views/interview-questions/js/es6.md","filePath":"views/interview-questions/js/es6.md"}'),l={name:"views/interview-questions/js/es6.md"},t=i(`<h1 id="es6" tabindex="-1">ES6+ <a class="header-anchor" href="#es6" aria-label="Permalink to &quot;ES6+&quot;">​</a></h1><h2 id="_1-es6-新特性" tabindex="-1">1. ES6 新特性 <a class="header-anchor" href="#_1-es6-新特性" aria-label="Permalink to &quot;1. ES6 新特性&quot;">​</a></h2><ol><li><code>const</code>和<code>let</code></li><li>模板字符串</li><li>箭头函数</li><li>函数的参数默认值</li><li>对象和数组解构</li><li><code>for...of</code>和<code>for...in</code></li><li><code>ES6</code>中的类</li><li><code>Promise</code></li></ol><h2 id="_2-map和set的区别-map和object的区别" tabindex="-1">2. Map和Set的区别，Map和Object的区别 <a class="header-anchor" href="#_2-map和set的区别-map和object的区别" aria-label="Permalink to &quot;2. Map和Set的区别，Map和Object的区别&quot;">​</a></h2><h3 id="map-和-set-的区别" tabindex="-1">Map 和 Set 的区别： <a class="header-anchor" href="#map-和-set-的区别" aria-label="Permalink to &quot;Map 和 Set 的区别：&quot;">​</a></h3><ul><li>Map：Map 是一种键值对的集合，其中每个键都是唯一的。你可以通过键来获取对应的值。Map 中的键可以是任意数据类型，包括对象、函数、基本数据类型等。</li><li>Set：Set 是一种值的集合，其中每个值都是唯一的。Set 中不允许重复的值存在，确保集合中的元素是唯一的。</li></ul><h3 id="map-和-object-的区别" tabindex="-1">Map 和 Object 的区别： <a class="header-anchor" href="#map-和-object-的区别" aria-label="Permalink to &quot;Map 和 Object 的区别：&quot;">​</a></h3><ul><li>Map：Map 是一种更加通用的键值对集合，与 Object 相比，Map 提供了更多的方法和功能。Map 的键可以是任意数据类型，并且会保持插入顺序。另外，Map 的键值对数量可以通过 size 属性轻松获取。</li><li>Object：Object 是 JavaScript 中的内置数据结构，用于存储键值对。在 Object 中，键只能是字符串或 Symbol 类型。Object 适合用来表示简单的键值对，但不如 Map 强大和灵活。</li></ul><h3 id="总结来说" tabindex="-1">总结来说 <a class="header-anchor" href="#总结来说" aria-label="Permalink to &quot;总结来说&quot;">​</a></h3><p>Map 和 Set 提供了更多的灵活性和功能，适合处理更复杂的数据结构；而 Object 则更适合处理简单的键值对数据。</p><h2 id="_3-let-与-var-与-const-的区别" tabindex="-1">3. let 与 var 与 const 的区别 <a class="header-anchor" href="#_3-let-与-var-与-const-的区别" aria-label="Permalink to &quot;3. let 与 var 与 const 的区别&quot;">​</a></h2><ul><li><code>var</code>声明的变量会挂载在<code>window</code>上，而<code>let</code>和<code>const</code>声明的变量不会</li><li><code>var</code>声明的变量存在变量提升,<code>let</code>和<code>const</code>不存在变量提升</li><li>同一作用域下<code>var</code>可以声明同名变量,<code>let</code>和<code>const</code>不可以</li><li><code>let</code>和<code>const</code>声明会形成块级作用域</li><li><code>const</code>一旦声明必须赋值，不能用<code>null</code>占位，声明后不能再修改，如果声明的是复合类型数据，可以修改属性</li></ul><h3 id="如果希望const定义的对象的属性也不能被修改该怎么做" tabindex="-1">如果希望const定义的对象的属性也不能被修改该怎么做 <a class="header-anchor" href="#如果希望const定义的对象的属性也不能被修改该怎么做" aria-label="Permalink to &quot;如果希望const定义的对象的属性也不能被修改该怎么做&quot;">​</a></h3><blockquote><p>希望对象的属性也不能被修改，可以使用 Object.freeze() 方法来冻结对象。</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  key1: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;value1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  key2: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;value2&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">freeze</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 禁止修改已有属性的值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj.key1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;new value&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这里的赋值操作不会生效</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 禁止添加新的属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj.key3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;value3&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这个属性添加操作也不会生效</span></span></code></pre></div><p>使用 Object.freeze() 方法冻结了 obj 对象，使得该对象及其属性都不可被修改。</p><p>需要注意的是，Object.freeze() 是浅冻结，意味着它只会冻结对象的直接属性，而不会冻结嵌套对象的属性。如果需要深度冻结整个对象，可以考虑使用一些库或自行编写函数来实现深度冻结。</p><p>另外，使用 Object.freeze() 后，对象及其属性将变为只读，无法再进行修改、添加或删除。</p><h2 id="_4-箭头函数与普通函数的区别" tabindex="-1">4. 箭头函数与普通函数的区别 <a class="header-anchor" href="#_4-箭头函数与普通函数的区别" aria-label="Permalink to &quot;4. 箭头函数与普通函数的区别&quot;">​</a></h2><ul><li>箭头函数是匿名函数，不能作为构造函数</li><li>箭头函数不能使用<code>new</code>,</li><li>箭头函数不能绑定<code>arguments</code>，要用<code>rest</code>参数解决</li><li>箭头函数没有原型属性</li><li>箭头函数的<code>this</code>永远指向其上下文的<code>this</code></li><li>箭头函数不能绑定<code>this</code>，会捕获其所在的上下文的<code>this</code>值，作为自己的<code>this</code>值</li></ul>`,20),n=[t];function o(c,h,p,d,r,k){return a(),s("div",null,n)}const u=e(l,[["render",o]]);export{b as __pageData,u as default};
