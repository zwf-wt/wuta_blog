import{_ as a,o as e,c as r,R as i}from"./chunks/framework.MMMQMGZx.js";const q=JSON.parse('{"title":"二叉搜索树","description":"","frontmatter":{},"headers":[],"relativePath":"views/algorithm/binarysearchtree.md","filePath":"views/algorithm/binarysearchtree.md"}'),t={name:"views/algorithm/binarysearchtree.md"},l=i('<h1 id="二叉搜索树" tabindex="-1">二叉搜索树 <a class="header-anchor" href="#二叉搜索树" aria-label="Permalink to &quot;二叉搜索树&quot;">​</a></h1><h2 id="定义及特点" tabindex="-1">定义及特点 <a class="header-anchor" href="#定义及特点" aria-label="Permalink to &quot;定义及特点&quot;">​</a></h2><p>二叉搜索树又名二叉查找树，有序二叉树或者排序二叉树，是二叉树中比较常用的一种类型。 二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</p><h2 id="二叉搜索树的实现" tabindex="-1">二叉搜索树的实现 <a class="header-anchor" href="#二叉搜索树的实现" aria-label="Permalink to &quot;二叉搜索树的实现&quot;">​</a></h2><h3 id="插入操作" tabindex="-1">插入操作 <a class="header-anchor" href="#插入操作" aria-label="Permalink to &quot;插入操作&quot;">​</a></h3><p>二叉搜索树的插入操作要先从根节点开始依次比较要插入的数据和节点的数据的大小并以此判断是将数据插入其左子树还是右子树，直到找到一个空节点，将数据插入到该节点中，如果该节点不是空节点，则继续比较直到找到一个空节点，将数据插入到该节点中。 如果要插入的数据比节点数值大，并且节点的右子树为空，则将数据插入到该节点的右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。</p><h3 id="删除操作" tabindex="-1">删除操作 <a class="header-anchor" href="#删除操作" aria-label="Permalink to &quot;删除操作&quot;">​</a></h3><p>删除操作分为三种情况：</p><ol><li>删除的节点是叶子节点，直接删除。只需要将父节点中指向该节点的指针置为null即可。</li><li>删除的节点有一个子节点，用子节点代替删除节点的位置。</li><li>删除的节点有两个及以上子节点，先在删除节点右子树中的最小节点，将最小节点赋值给要删除的节点，并且删除最小节点</li></ol><h3 id="查找最值" tabindex="-1">查找最值 <a class="header-anchor" href="#查找最值" aria-label="Permalink to &quot;查找最值&quot;">​</a></h3><p>对于查找二叉查找树的最小值，我们只需要从根节点开始依次查找其左子节点直到最后的叶子节点，最后的叶子节点就是其最小值，同理查找最大值只需要从根节点开始依次查找其右子节点直到最后的叶子节点，最后的叶子节点就是其最大值。</p><h3 id="时间复杂度分析" tabindex="-1">时间复杂度分析 <a class="header-anchor" href="#时间复杂度分析" aria-label="Permalink to &quot;时间复杂度分析&quot;">​</a></h3><p>log(n)</p><h3 id="对比散列表" tabindex="-1">对比散列表 <a class="header-anchor" href="#对比散列表" aria-label="Permalink to &quot;对比散列表&quot;">​</a></h3><ol><li>散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，只需要中序遍历，就可以在O(n)的时间复杂度内，输了有序的数据序列。</li><li>散列表扩容耗时很多，而且当遇到散列冲突时，查找效率会变得很低，性能不稳定，尽管二叉查找树的性能也不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂稳定在O(log(n))。</li><li>尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比logn小，所以实际的查找速度可能不一定比 O(ogn)快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率 高。</li><li>散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</li><li>为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。 综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。我们在实际的开发过程中，需要结合具体的需求来选择。</li></ol><h2 id="实战题目" tabindex="-1">实战题目 <a class="header-anchor" href="#实战题目" aria-label="Permalink to &quot;实战题目&quot;">​</a></h2><h3 id="_95" tabindex="-1">95 <a class="header-anchor" href="#_95" aria-label="Permalink to &quot;95&quot;">​</a></h3><h3 id="_96" tabindex="-1">96 <a class="header-anchor" href="#_96" aria-label="Permalink to &quot;96&quot;">​</a></h3><h3 id="_108" tabindex="-1">108 <a class="header-anchor" href="#_108" aria-label="Permalink to &quot;108&quot;">​</a></h3><h3 id="_144" tabindex="-1">144 <a class="header-anchor" href="#_144" aria-label="Permalink to &quot;144&quot;">​</a></h3>',20),o=[l];function h(n,s,d,c,_,u){return e(),r("div",null,o)}const m=a(t,[["render",h]]);export{q as __pageData,m as default};
